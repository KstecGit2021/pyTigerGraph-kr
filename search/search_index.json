{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyTigerGraph pyTigerGraph is a Python package for connecting to TigerGraph databases. Getting Started To download pyTigerGraph, simply run: pip3 install pyTigerGraph Once the package installs, you can import it and instantiate a connection to your database: import pyTigerGraph as tg conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", username=\"<username>\", password=\"<password>\", apiToken=\"<api_token>\") If your database is not using the standard ports (or they are mapped), you can use the following arguments to specify those: - restppPort (default 9000): REST++ API port - gsPort (default: 14240): GraphStudio port For example, in case of using a local virtual machine with the ports mapped: conn = tg.TigerGraphConnection(host=\"localhost\", restppPort=25900, gsPort=25240, graphname=\"MyGraph\", username=\"tigergraph\", password=\"tigergraph\", apiToken=\"2aa016d747ede9gg6da3drslm98srfoj\") For more details on establishing a connection, read the Getting Started page. Example Projects GSQL101 on a notebook Connecting to TigerGraph Database with pyTigerGraph Predicting IPOs using Graph Convolutional Neural Networks Using pyTigergraph With Plotly TigerGraph to Tensorflow Movie Prediction with Graph Convolutional Neural Networks Credits pyTigerGraph was originally created by Parker Erickson, a Computer Science student at the University of Minnesota. Special thanks to contributors Jon Herke and Szilard Barany of TigerGraph. Read this to learn more about how you can contribute.","title":"Home"},{"location":"#pytigergraph","text":"pyTigerGraph is a Python package for connecting to TigerGraph databases.","title":"pyTigerGraph"},{"location":"#getting-started","text":"To download pyTigerGraph, simply run: pip3 install pyTigerGraph Once the package installs, you can import it and instantiate a connection to your database: import pyTigerGraph as tg conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", username=\"<username>\", password=\"<password>\", apiToken=\"<api_token>\") If your database is not using the standard ports (or they are mapped), you can use the following arguments to specify those: - restppPort (default 9000): REST++ API port - gsPort (default: 14240): GraphStudio port For example, in case of using a local virtual machine with the ports mapped: conn = tg.TigerGraphConnection(host=\"localhost\", restppPort=25900, gsPort=25240, graphname=\"MyGraph\", username=\"tigergraph\", password=\"tigergraph\", apiToken=\"2aa016d747ede9gg6da3drslm98srfoj\") For more details on establishing a connection, read the Getting Started page.","title":"Getting Started"},{"location":"#example-projects","text":"GSQL101 on a notebook Connecting to TigerGraph Database with pyTigerGraph Predicting IPOs using Graph Convolutional Neural Networks Using pyTigergraph With Plotly TigerGraph to Tensorflow Movie Prediction with Graph Convolutional Neural Networks","title":"Example Projects"},{"location":"#credits","text":"pyTigerGraph was originally created by Parker Erickson, a Computer Science student at the University of Minnesota. Special thanks to contributors Jon Herke and Szilard Barany of TigerGraph. Read this to learn more about how you can contribute.","title":"Credits"},{"location":"Auth/","text":"Authentication If GSQL authentication is enabled in the TigerGraph database, then username and password need to be specified when the connection is established. If REST++ authentication is enabled, and you already have an API authorization token, specify that one as well. Alternatively, if you posess a secret (created previously in the database), you can request a token via the getToken function and use it during the session. See Token Management for more details. When establising a connection the username and password default to the TigerGraph default username and password, which are tigergraph . If user authentication is to e enabled, the tigergraph user's password must be changed. Furthermore, it is recommended not to use the tigergraph user for anything other than system administration. Instead, create additional users and grant them the appropriate privileges through roles , then use those users to access the database. It is recommended to not push any form of authentication information to version control software. Because of this, we recommend to create a cfg.py file that looks like this: secret = \"YOUR_SECRET_HERE\" token = \"\" password = \"YOUR_PASSWORD_HERE\" You can then import this config file into your Python applications, and add cfg.py to your .gitignore . To create a connection to your database, simply: import pyTigerGraph as tg import cfg cfg.token = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\").getToken(cfg.secret, \"<token_lifetime>\")[0] conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", password=cfg.password, apiToken=cfg.token) Substitute the hostname and graph name with the correct credentials, as well as the desired lifetime of the API token fetched.","title":"Authentication"},{"location":"Auth/#authentication","text":"If GSQL authentication is enabled in the TigerGraph database, then username and password need to be specified when the connection is established. If REST++ authentication is enabled, and you already have an API authorization token, specify that one as well. Alternatively, if you posess a secret (created previously in the database), you can request a token via the getToken function and use it during the session. See Token Management for more details. When establising a connection the username and password default to the TigerGraph default username and password, which are tigergraph . If user authentication is to e enabled, the tigergraph user's password must be changed. Furthermore, it is recommended not to use the tigergraph user for anything other than system administration. Instead, create additional users and grant them the appropriate privileges through roles , then use those users to access the database. It is recommended to not push any form of authentication information to version control software. Because of this, we recommend to create a cfg.py file that looks like this: secret = \"YOUR_SECRET_HERE\" token = \"\" password = \"YOUR_PASSWORD_HERE\" You can then import this config file into your Python applications, and add cfg.py to your .gitignore . To create a connection to your database, simply: import pyTigerGraph as tg import cfg cfg.token = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\").getToken(cfg.secret, \"<token_lifetime>\")[0] conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", password=cfg.password, apiToken=cfg.token) Substitute the hostname and graph name with the correct credentials, as well as the desired lifetime of the API token fetched.","title":"Authentication"},{"location":"CONTRIBUTING/","text":"Contribute to pyTigerGraph It is easy! Just follow the steps below: Fork the Original Repo Clone your forked Version Make additions, modifications Run git fetch upstream <branch> to make sure both repos are in sync Push to your forked Repo Issue Pull Request to the original repository","title":"Contribute"},{"location":"CONTRIBUTING/#contribute-to-pytigergraph","text":"It is easy! Just follow the steps below: Fork the Original Repo Clone your forked Version Make additions, modifications Run git fetch upstream <branch> to make sure both repos are in sync Push to your forked Repo Issue Pull Request to the original repository","title":"Contribute to pyTigerGraph"},{"location":"DataFrame/","text":"Pandas DataFrame Support This submodule provides results from various built-in endpoints in a Pandas DataFrame. For this module to work, you will have to install the Pandas module, by running pip install pandas . Take a look here for some demos displaying some of the functionality. getVertexDataframe getVertexDataframe(vertexType, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Returns the verticies of a given vertex type that conform to the various arguments. Arguments: vertexType : Type of vertex desired select : Comma separated list of vertex attributes to be retrieved or omitted. Details where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Details limit : Maximum number of vertex instances to be returned (after sorting). Details sort : Comma separated list of attributes the results should be sorted by. Details timeout : Time allowed for successful execution (0 = no limit, default). getVertexDataframeByID getVertexDataframeByID(vertexType, vertexIds) Retrieves vertices of the given vertex type, identified by their ID. Arguments: - vertexType : Type of vertex desired - vertexIds : A list of vertex IDs. upsertVertexDataFrame upsertVertexDataframe(df, vertexType, v_id=None, attributes=None) Upserts vertices from a Pandas DataFrame. Arguments: - df : The DataFrame to upsert. - vertexType : The type of vertex to upsert data to. - v_id : The field name where the vertex primary id is given. If omitted the dataframe index will be used instead. - attributes : A dictionary in the form of {target: source} where source is the column name in the dataframe and target is the attribute name in the graph vertex. When omitted all columns would be upserted with their current names. In this case column names must match the vertex's attribute names. vertexSetToDataFrame vertexSetToDataFrame(vertexSet, withId=True, withType=False) Converts a vertex set to Pandas DataFrame. Arguments: - vertexSet : A vertex set (a list of vertices of the same vertex type). - withId : Add a column with vertex IDs to the DataFrame. - withType : Add a column with vertex type to the DataFrame. Vertex sets are used for both the input and output of SELECT statements. They contain instances of vertices of the same type. For each vertex instance the vertex ID, the vertex type and the (optional) attributes are present (under v_id , v_type and attributes keys, respectively). See example in edgeSetToDataFrame . A vertex set has this structure: [ { \"v_id\": <vertex_id>, \"v_type\": <vertex_type_name>, \"attributes\": { \"attr1\": <value1>, \"attr2\": <value2>, \u22ee } }, \u22ee ] See: https://docs.tigergraph.com/dev/gsql-ref/querying/declaration-and-assignment-statements#vertex-set-variable-declaration-and-assignment getEdgesDataframe getEdgesDataframe(sourceVertexType, sourceVerticies, edgeType=None, targetVertexType=None, targetVertexId=None, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves edges of the given edge type originating from the list of source verticies. Only sourceVertexType and sourceVerticies are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: select : Comma separated list of edge attributes to be retrieved or omitted. Details where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Details limit : Maximum number of edge instances to be returned (after sorting). Details sort Comma separated list of attributes the results should be sorted by. Details upsertEdgeDataFrame upsertEdgeDataFrame(df, sourceVertexType, edgeType, targetVertexType, from_id=None, to_id=None, attributes=None) Upserts edges from a Pandas dataframe. Arguments: - df : The dataframe to upsert. - sourceVertexType : The type of source vertex for the edge. - edgeType : The type of edge to upsert data to. - targetVertexType : The type of target vertex for the edge. - from_id : The field name where the source vertex primary id is given. If omitted the dataframe index would be used instead. - to_id : The field name where the target vertex primary id is given. If omitted the dataframe index would be used instead. - attributes : A dictionary in the form of {target: source} where source is the column name in the dataframe and target is the attribute name in the graph vertex. When omitted all columns would be upserted with their current names. In this case column names must match the vertex's attribute names. edgeSetToDataFrame edgeSetToDataFrame(self, edgeSet, withId=True, withType=False) Converts an edge set to Pandas DataFrame. Arguments: - edgeSet : An edge set (a list of edges of the same edge type). - withId : Add a column with edge IDs to the DataFrame. - Note: As edges do not have internal ID, this column will contain a generated composite ID, a combination of source and target vertex types and IDs (specifically: [<source vertex type>, <source vertex ID>, <target vertex type>, <target vertex ID>] ). This is unique within the vertex type, but not guaranteed to be globally (i.e. within the whole graph) unique. To get a globally unique edge id, the edge type needs to be added to the above combination (see withType below). - withType : Add a column with edge type to the DataFrame. - Note: The value of this column should be combined with the value of ID column to get a globally unique edge ID. Edge sets contain instances of the same edge type. Edge sets are not generated \"naturally\" like vertex sets, you need to collect edges in (global) accumulators, e.g. in case you want to visualise them in GraphStudio or by other tools. Example: SetAccum<EDGE> @@edges; start = {Country.*}; result = SELECT t FROM start:s -(PROVINCE_IN_COUNTRY:e)- Province:t ACCUM @@edges += e; PRINT start, result, @@edges; The @@edges is an edge set. It contains for each edge instance the source and target vertex type and ID, the edge type, an directedness indicator and the (optional) attributes. Note: start and result are vertex sets. An edge set has this structure: [ { \"e_type\": <edge_type_name>, \"from_type\": <source_vertex_type_name>, \"from_id\": <source_vertex_id>, \"to_type\": <target_vertex_type_name>, \"to_id\": <targe_vertex_id>, \"directed\": <true_or_false>, \"attributes\": { \"attr1\": <value1>, \"attr2\": <value2>, \u22ee } }, \u22ee ] getInstalledQueriesDataframe getInstalledQueriesDataframe() Returns dataframe of all installed queries, does not take any arguments.","title":"DataFrame Functions"},{"location":"DataFrame/#pandas-dataframe-support","text":"This submodule provides results from various built-in endpoints in a Pandas DataFrame. For this module to work, you will have to install the Pandas module, by running pip install pandas . Take a look here for some demos displaying some of the functionality.","title":"Pandas DataFrame Support"},{"location":"DataFrame/#getvertexdataframe","text":"getVertexDataframe(vertexType, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Returns the verticies of a given vertex type that conform to the various arguments. Arguments: vertexType : Type of vertex desired select : Comma separated list of vertex attributes to be retrieved or omitted. Details where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Details limit : Maximum number of vertex instances to be returned (after sorting). Details sort : Comma separated list of attributes the results should be sorted by. Details timeout : Time allowed for successful execution (0 = no limit, default).","title":"getVertexDataframe"},{"location":"DataFrame/#getvertexdataframebyid","text":"getVertexDataframeByID(vertexType, vertexIds) Retrieves vertices of the given vertex type, identified by their ID. Arguments: - vertexType : Type of vertex desired - vertexIds : A list of vertex IDs.","title":"getVertexDataframeByID"},{"location":"DataFrame/#upsertvertexdataframe","text":"upsertVertexDataframe(df, vertexType, v_id=None, attributes=None) Upserts vertices from a Pandas DataFrame. Arguments: - df : The DataFrame to upsert. - vertexType : The type of vertex to upsert data to. - v_id : The field name where the vertex primary id is given. If omitted the dataframe index will be used instead. - attributes : A dictionary in the form of {target: source} where source is the column name in the dataframe and target is the attribute name in the graph vertex. When omitted all columns would be upserted with their current names. In this case column names must match the vertex's attribute names.","title":"upsertVertexDataFrame"},{"location":"DataFrame/#vertexsettodataframe","text":"vertexSetToDataFrame(vertexSet, withId=True, withType=False) Converts a vertex set to Pandas DataFrame. Arguments: - vertexSet : A vertex set (a list of vertices of the same vertex type). - withId : Add a column with vertex IDs to the DataFrame. - withType : Add a column with vertex type to the DataFrame. Vertex sets are used for both the input and output of SELECT statements. They contain instances of vertices of the same type. For each vertex instance the vertex ID, the vertex type and the (optional) attributes are present (under v_id , v_type and attributes keys, respectively). See example in edgeSetToDataFrame . A vertex set has this structure: [ { \"v_id\": <vertex_id>, \"v_type\": <vertex_type_name>, \"attributes\": { \"attr1\": <value1>, \"attr2\": <value2>, \u22ee } }, \u22ee ] See: https://docs.tigergraph.com/dev/gsql-ref/querying/declaration-and-assignment-statements#vertex-set-variable-declaration-and-assignment","title":"vertexSetToDataFrame"},{"location":"DataFrame/#getedgesdataframe","text":"getEdgesDataframe(sourceVertexType, sourceVerticies, edgeType=None, targetVertexType=None, targetVertexId=None, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves edges of the given edge type originating from the list of source verticies. Only sourceVertexType and sourceVerticies are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: select : Comma separated list of edge attributes to be retrieved or omitted. Details where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Details limit : Maximum number of edge instances to be returned (after sorting). Details sort Comma separated list of attributes the results should be sorted by. Details","title":"getEdgesDataframe"},{"location":"DataFrame/#upsertedgedataframe","text":"upsertEdgeDataFrame(df, sourceVertexType, edgeType, targetVertexType, from_id=None, to_id=None, attributes=None) Upserts edges from a Pandas dataframe. Arguments: - df : The dataframe to upsert. - sourceVertexType : The type of source vertex for the edge. - edgeType : The type of edge to upsert data to. - targetVertexType : The type of target vertex for the edge. - from_id : The field name where the source vertex primary id is given. If omitted the dataframe index would be used instead. - to_id : The field name where the target vertex primary id is given. If omitted the dataframe index would be used instead. - attributes : A dictionary in the form of {target: source} where source is the column name in the dataframe and target is the attribute name in the graph vertex. When omitted all columns would be upserted with their current names. In this case column names must match the vertex's attribute names.","title":"upsertEdgeDataFrame"},{"location":"DataFrame/#edgesettodataframe","text":"edgeSetToDataFrame(self, edgeSet, withId=True, withType=False) Converts an edge set to Pandas DataFrame. Arguments: - edgeSet : An edge set (a list of edges of the same edge type). - withId : Add a column with edge IDs to the DataFrame. - Note: As edges do not have internal ID, this column will contain a generated composite ID, a combination of source and target vertex types and IDs (specifically: [<source vertex type>, <source vertex ID>, <target vertex type>, <target vertex ID>] ). This is unique within the vertex type, but not guaranteed to be globally (i.e. within the whole graph) unique. To get a globally unique edge id, the edge type needs to be added to the above combination (see withType below). - withType : Add a column with edge type to the DataFrame. - Note: The value of this column should be combined with the value of ID column to get a globally unique edge ID. Edge sets contain instances of the same edge type. Edge sets are not generated \"naturally\" like vertex sets, you need to collect edges in (global) accumulators, e.g. in case you want to visualise them in GraphStudio or by other tools. Example: SetAccum<EDGE> @@edges; start = {Country.*}; result = SELECT t FROM start:s -(PROVINCE_IN_COUNTRY:e)- Province:t ACCUM @@edges += e; PRINT start, result, @@edges; The @@edges is an edge set. It contains for each edge instance the source and target vertex type and ID, the edge type, an directedness indicator and the (optional) attributes. Note: start and result are vertex sets. An edge set has this structure: [ { \"e_type\": <edge_type_name>, \"from_type\": <source_vertex_type_name>, \"from_id\": <source_vertex_id>, \"to_type\": <target_vertex_type_name>, \"to_id\": <targe_vertex_id>, \"directed\": <true_or_false>, \"attributes\": { \"attr1\": <value1>, \"attr2\": <value2>, \u22ee } }, \u22ee ]","title":"edgeSetToDataFrame"},{"location":"DataFrame/#getinstalledqueriesdataframe","text":"getInstalledQueriesDataframe() Returns dataframe of all installed queries, does not take any arguments.","title":"getInstalledQueriesDataframe"},{"location":"EdgeFunctions/","text":"getEdgeTypes getEdgeTypes() Returns the list of edge type names of the graph. getEdgeType getEdgeType(typeName) Returns the details of vertex type. getEdgeCountFrom getEdgeCount(sourceVertexType=None, sourceVertexId=None, edgeType=None, targetVertexType=None, targetVertexId=None, where=\"\") Returns the number of edges. Arguments: - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Uses: - If edgeType = \"*\": edge count of all edge types (no other arguments can be specified in this case). - If edgeType is specified only: edge count of the given edge type. - If sourceVertexType , edgeType , targetVertexType are specified: edge count of the given edge type between source and target vertex types. - If sourceVertexType , sourceVertexId are specified: edge count of all edge types from the given vertex instance. - If sourceVertexType , sourceVertexId , edgeType are specified: edge count of all edge types from the given vertex instance. - If sourceVertexType , sourceVertexId , edgeType , where are specified: the edge count of the given edge type after filtered by where condition. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Returns a dictionary of <edge_type>: <edge_count> pairs. Documentation: GET /graph/{graph_name}/edges and POST /builtins getEdgeCount getEdgeCount(self, edgeType=\"*\", sourceVertexType=None, targetVertexType=None) Returns the number of edges of an edge type. This is a simplified version of getEdgeCountFrom , to be used when the total number of edges of a given type is needed, regardless which vertex instance they are originated from. See documentation of getEdgeCountFrom above for more details. upsertEdge upsertEdge(sourceVertexType, sourceVertexId, edgeType, targetVertexType, targetVertexId, attributes={}) Upserts an edge. Data is upserted: - If edge is not yet present in graph, it will be created (see special case below). - If it's already in the graph, it is updated with the values specified in the request. An optional operator controls how the attributes are updated. The attributes argument is expected to be a dictionary in this format: {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026} Example: {\"visits\": (1482, \"+\"), \"max_duration\": (371, \"max\")} Returns a single number of accepted (successfully upserted) edges (0 or 1). Note: If operator is \"vertex_must_exist\" then edge will only be created if both vertex exists in graph. Otherwise missing vertices are created with the new edge. Documentation: POST /graph upsertEdges upsertEdges(sourceVertexType, edgeType, targetVertexType, edges) Upserts multiple edges (of the same type). See the description of upsertEdge for generic information. The edges argument is expected to be a list in of tuples in this format: [ (<source_vertex_id>, <target_vertex_id>, {<attribute_name>: <attribute_value>|(<attribute_name>, <operator>), \u2026}) \u22ee ] Example: [ (17, \"home_page\", {\"visits\": (35, \"+\"), \"max_duration\": (93, \"max\")}), (42, \"search\", {\"visits\": (17, \"+\"), \"max_duration\": (41, \"max\")}), ] Returns a single number of accepted (successfully upserted) edges (0 or positive integer). Documentation: POST /graph getEdges getEdges(sourceVertexType, sourceVertexId, edgeType=None, targetVertexType=None, targetVertexId=None, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves edges of the given edge type. Only sourceVertexType and sourceVertexId are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: - select : Comma separated list of edge attributes to be retrieved or omitted. - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of edge instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. Documentation: GET /graph/{graph_name}/vertices getEdgeStats getEdgeStats(edgeTypes, skipNA=False) Returns edge attribute statistics. Arguments: - edgeTypes : A single edge type name or a list of edges types names or '*' for all edges types. - skipNA : Skip those n on- a pplicable edges that do not have attributes or none of their attributes have statistics gathered. Documentation: POST /builtins delEdges delEdges(sourceVertexType, sourceVertexId, edgeType=None, targetVertexType=None, targetVertexId=None, where=\"\", limit=\"\", sort=\"\", timeout=0) Deletes edges from the graph. Only sourceVertexType and sourceVertexId are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of edge instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. - timeout : Time allowed for successful execution (0 = no limit, default). Returns a dictionary of <edge_type>: <deleted_edge_count> pairs. Documentation: DELETE /graph/{/graph_name}/edges","title":"Edge Functions"},{"location":"EdgeFunctions/#getedgetypes","text":"getEdgeTypes() Returns the list of edge type names of the graph.","title":"getEdgeTypes"},{"location":"EdgeFunctions/#getedgetype","text":"getEdgeType(typeName) Returns the details of vertex type.","title":"getEdgeType"},{"location":"EdgeFunctions/#getedgecountfrom","text":"getEdgeCount(sourceVertexType=None, sourceVertexId=None, edgeType=None, targetVertexType=None, targetVertexId=None, where=\"\") Returns the number of edges. Arguments: - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Uses: - If edgeType = \"*\": edge count of all edge types (no other arguments can be specified in this case). - If edgeType is specified only: edge count of the given edge type. - If sourceVertexType , edgeType , targetVertexType are specified: edge count of the given edge type between source and target vertex types. - If sourceVertexType , sourceVertexId are specified: edge count of all edge types from the given vertex instance. - If sourceVertexType , sourceVertexId , edgeType are specified: edge count of all edge types from the given vertex instance. - If sourceVertexType , sourceVertexId , edgeType , where are specified: the edge count of the given edge type after filtered by where condition. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Returns a dictionary of <edge_type>: <edge_count> pairs. Documentation: GET /graph/{graph_name}/edges and POST /builtins","title":"getEdgeCountFrom"},{"location":"EdgeFunctions/#getedgecount","text":"getEdgeCount(self, edgeType=\"*\", sourceVertexType=None, targetVertexType=None) Returns the number of edges of an edge type. This is a simplified version of getEdgeCountFrom , to be used when the total number of edges of a given type is needed, regardless which vertex instance they are originated from. See documentation of getEdgeCountFrom above for more details.","title":"getEdgeCount"},{"location":"EdgeFunctions/#upsertedge","text":"upsertEdge(sourceVertexType, sourceVertexId, edgeType, targetVertexType, targetVertexId, attributes={}) Upserts an edge. Data is upserted: - If edge is not yet present in graph, it will be created (see special case below). - If it's already in the graph, it is updated with the values specified in the request. An optional operator controls how the attributes are updated. The attributes argument is expected to be a dictionary in this format: {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026} Example: {\"visits\": (1482, \"+\"), \"max_duration\": (371, \"max\")} Returns a single number of accepted (successfully upserted) edges (0 or 1). Note: If operator is \"vertex_must_exist\" then edge will only be created if both vertex exists in graph. Otherwise missing vertices are created with the new edge. Documentation: POST /graph","title":"upsertEdge"},{"location":"EdgeFunctions/#upsertedges","text":"upsertEdges(sourceVertexType, edgeType, targetVertexType, edges) Upserts multiple edges (of the same type). See the description of upsertEdge for generic information. The edges argument is expected to be a list in of tuples in this format: [ (<source_vertex_id>, <target_vertex_id>, {<attribute_name>: <attribute_value>|(<attribute_name>, <operator>), \u2026}) \u22ee ] Example: [ (17, \"home_page\", {\"visits\": (35, \"+\"), \"max_duration\": (93, \"max\")}), (42, \"search\", {\"visits\": (17, \"+\"), \"max_duration\": (41, \"max\")}), ] Returns a single number of accepted (successfully upserted) edges (0 or positive integer). Documentation: POST /graph","title":"upsertEdges"},{"location":"EdgeFunctions/#getedges","text":"getEdges(sourceVertexType, sourceVertexId, edgeType=None, targetVertexType=None, targetVertexId=None, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves edges of the given edge type. Only sourceVertexType and sourceVertexId are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: - select : Comma separated list of edge attributes to be retrieved or omitted. - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of edge instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. Documentation: GET /graph/{graph_name}/vertices","title":"getEdges"},{"location":"EdgeFunctions/#getedgestats","text":"getEdgeStats(edgeTypes, skipNA=False) Returns edge attribute statistics. Arguments: - edgeTypes : A single edge type name or a list of edges types names or '*' for all edges types. - skipNA : Skip those n on- a pplicable edges that do not have attributes or none of their attributes have statistics gathered. Documentation: POST /builtins","title":"getEdgeStats"},{"location":"EdgeFunctions/#deledges","text":"delEdges(sourceVertexType, sourceVertexId, edgeType=None, targetVertexType=None, targetVertexId=None, where=\"\", limit=\"\", sort=\"\", timeout=0) Deletes edges from the graph. Only sourceVertexType and sourceVertexId are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of edge instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. - timeout : Time allowed for successful execution (0 = no limit, default). Returns a dictionary of <edge_type>: <deleted_edge_count> pairs. Documentation: DELETE /graph/{/graph_name}/edges","title":"delEdges"},{"location":"Functions/","text":"The Functions Common arguments used in methods: - vertexType , sourceVertexType , targetVertexType : The name of a vertex type in the graph. Use getVertexTypes to fetch the list of vertex types currently in the graph. - vertexId , sourceVertexId , targetVertexId : The primary ID of a vertex instance (of the appropriate data type). - edgeType : The name of the edge type in the graph. Use getEdgeTypes to fetch the list of edge types currently in the graph. Schema related functions Query related functions Vertex related functions Edge related functions Token management Other functions getSchema runInstalledQuery getVertexTypes getEdgeTypes getToken echo getUDTs runInterpretedQuery getVertexType getEdgeType refreshToken getEndpoints getUDT getVertexCount getEdgeCount deleteToken getStatistics upsertData upsertVertex upsertEdge getVersion upsertVertices upsertEdges getVer getVertices getEdges getLicenseInfo getVerticesById getEdgeStats getVertexStats delEdges delVertices delVerticesById","title":"Overview"},{"location":"Functions/#the-functions","text":"Common arguments used in methods: - vertexType , sourceVertexType , targetVertexType : The name of a vertex type in the graph. Use getVertexTypes to fetch the list of vertex types currently in the graph. - vertexId , sourceVertexId , targetVertexId : The primary ID of a vertex instance (of the appropriate data type). - edgeType : The name of the edge type in the graph. Use getEdgeTypes to fetch the list of edge types currently in the graph. Schema related functions Query related functions Vertex related functions Edge related functions Token management Other functions getSchema runInstalledQuery getVertexTypes getEdgeTypes getToken echo getUDTs runInterpretedQuery getVertexType getEdgeType refreshToken getEndpoints getUDT getVertexCount getEdgeCount deleteToken getStatistics upsertData upsertVertex upsertEdge getVersion upsertVertices upsertEdges getVer getVertices getEdges getLicenseInfo getVerticesById getEdgeStats getVertexStats delEdges delVertices delVerticesById","title":"The Functions"},{"location":"GettingStarted/","text":"Getting Started Establishing the connection to a TigerGraph database First, import pyTigerGraph: import pyTigerGraph as tg The functionality of pyTigerGraph is implemented by the TigerGraphConnection class. To establish the connection, instantiate the class: conn = tg.TigerGraphConnection(<parameters>) The constuctor has following parameters: host : The IP address or hostname of the TigerGraph server, including the scheme ( http or https ). Default: http://localhost . graphname : The default graph for running queries. Default: MyGraph . username : The username on the TigerGraph server. Default: tigergraph . password : The password for that user. Default: tigergraph . restppPort : The post for REST++ queries. Default: 9000 . gsPort : The port of all other queries. Default: 14240 . apiToken : A token to use when making queries. No default value. Required to upsert or delete data in garph. Ignored if REST++ authentication is not enabled . See Additional Info below. gsqlVersion : The version of GSQL client to be used. Default: same as database version. See GSQL Submodule for more details. useCert : True if SSL certificate is required for connection. Default: True See Additional Info below. certPath : The location/directory and the name of the SSL certification file where the certification should be stored. Default: ~/.gsql/my-cert.txt See Additional Info below. Connection Clarification Operations that DO NOT need a Token Viewing the schema of your graph using functions such as getSchema and getVertexTypes does not require you to have an authentication token. A token is also not required to run gsql commands through pyTigerGraph. Sample Connection conn = tg.TigerGraphConnection(host='https://pytigergraph-demo.i.tgcloud.io', username='tigergraph' password='password' graphname='DemoGraph') Operations that DO need a Token A token is required to view or modify any actual DATA in the graph. Examples are: upserting data, deleting edges, and getting stats about any loaded vertices. A token is also required to get version data about the TigerGraph instance. Sample Connection conn = tg.TigerGraphConnection(host='https://pytigergraph-demo.i.tgcloud.io', username='tigergraph' password='password' graphname='DemoGraph', apiToken='av1im8nd2v06clbnb424jj7fp09hp049') Additional Info As pyTigerGraph is communicating with the TigerGraph database through REST APIs, there is no real \"connection\". Most (but not all) function of pyTigerGraph sends (one or more) HTTP(s) request to the REST API and processes the data returned (typically a JSON response). Thus there is no \"connection\" that needs to be opened and then closed down. Instantiating pyTigerGraph simply means to provide the neccesary information to be able to send the requests and receive and response. See the Token Management page for information on how authentication works and how to retrieve and manage API tokens. If the TigerGraph database uses encrypted connections (e.g. TigerGraph could instances), then you need to provide an SSL certificate for your connections. In this case you need to specify useCert=True and the location of the SSL certificate in certPath . pyTigerGraph will generate and download a self-signed SSL certificate for you. If useCert=False or certPath is not set, pyTigerGraph will try to connect without certificate. useCert should be False if you connect to an unsecure server such as a TigerGraph Developer instance. NOTE: This functionality is not tested and most likely does not work on Windows. We intend to fix this; help is welcome (it seems all contributors are using Macs). GSQL 101 With pyTigerGraph Checkout this example for completing the GSQL 101 course in a Jupyter Notebook environment. Through this, you will also learn of various pyTigerGraph methods that you can use.","title":"Getting Started"},{"location":"GettingStarted/#getting-started","text":"","title":"Getting Started"},{"location":"GettingStarted/#establishing-the-connection-to-a-tigergraph-database","text":"First, import pyTigerGraph: import pyTigerGraph as tg The functionality of pyTigerGraph is implemented by the TigerGraphConnection class. To establish the connection, instantiate the class: conn = tg.TigerGraphConnection(<parameters>) The constuctor has following parameters: host : The IP address or hostname of the TigerGraph server, including the scheme ( http or https ). Default: http://localhost . graphname : The default graph for running queries. Default: MyGraph . username : The username on the TigerGraph server. Default: tigergraph . password : The password for that user. Default: tigergraph . restppPort : The post for REST++ queries. Default: 9000 . gsPort : The port of all other queries. Default: 14240 . apiToken : A token to use when making queries. No default value. Required to upsert or delete data in garph. Ignored if REST++ authentication is not enabled . See Additional Info below. gsqlVersion : The version of GSQL client to be used. Default: same as database version. See GSQL Submodule for more details. useCert : True if SSL certificate is required for connection. Default: True See Additional Info below. certPath : The location/directory and the name of the SSL certification file where the certification should be stored. Default: ~/.gsql/my-cert.txt See Additional Info below.","title":"Establishing the connection to a TigerGraph database"},{"location":"GettingStarted/#connection-clarification","text":"","title":"Connection Clarification"},{"location":"GettingStarted/#operations-that-do-not-need-a-token","text":"Viewing the schema of your graph using functions such as getSchema and getVertexTypes does not require you to have an authentication token. A token is also not required to run gsql commands through pyTigerGraph. Sample Connection conn = tg.TigerGraphConnection(host='https://pytigergraph-demo.i.tgcloud.io', username='tigergraph' password='password' graphname='DemoGraph')","title":"Operations that DO NOT need a Token"},{"location":"GettingStarted/#operations-that-do-need-a-token","text":"A token is required to view or modify any actual DATA in the graph. Examples are: upserting data, deleting edges, and getting stats about any loaded vertices. A token is also required to get version data about the TigerGraph instance. Sample Connection conn = tg.TigerGraphConnection(host='https://pytigergraph-demo.i.tgcloud.io', username='tigergraph' password='password' graphname='DemoGraph', apiToken='av1im8nd2v06clbnb424jj7fp09hp049')","title":"Operations that DO need a Token"},{"location":"GettingStarted/#additional-info","text":"As pyTigerGraph is communicating with the TigerGraph database through REST APIs, there is no real \"connection\". Most (but not all) function of pyTigerGraph sends (one or more) HTTP(s) request to the REST API and processes the data returned (typically a JSON response). Thus there is no \"connection\" that needs to be opened and then closed down. Instantiating pyTigerGraph simply means to provide the neccesary information to be able to send the requests and receive and response. See the Token Management page for information on how authentication works and how to retrieve and manage API tokens. If the TigerGraph database uses encrypted connections (e.g. TigerGraph could instances), then you need to provide an SSL certificate for your connections. In this case you need to specify useCert=True and the location of the SSL certificate in certPath . pyTigerGraph will generate and download a self-signed SSL certificate for you. If useCert=False or certPath is not set, pyTigerGraph will try to connect without certificate. useCert should be False if you connect to an unsecure server such as a TigerGraph Developer instance. NOTE: This functionality is not tested and most likely does not work on Windows. We intend to fix this; help is welcome (it seems all contributors are using Macs).","title":"Additional Info"},{"location":"GettingStarted/#gsql-101-with-pytigergraph","text":"Checkout this example for completing the GSQL 101 course in a Jupyter Notebook environment. Through this, you will also learn of various pyTigerGraph methods that you can use.","title":"GSQL 101 With pyTigerGraph"},{"location":"Gsql/","text":"GSQL Submodule pyTigerGraph uses the GSQL command line client to enable sending arbitrary GSQL statements to the database. This enables you to execute operations that are currently not available through REST API endpoints. The client is implemented in Java and distributed as a .jar archive. The client is downloaded on demand to the machine running your pyTigerGraph application; so you need to ensure that your code can access the download location and can save the .jar file locally. Furthermore, Java 8+ JRE must be installed and accessible on the machine. The .jar file is downloaded only if it's not yet available locally, i.e. it is downloaded only once for each database version accessed. Thus, you will potentially have multiple versions of the .jar file downloaded. The name pattern of the .jar file is gsql_client-x.y.z.jar , e.g. gsql_client-2.6.2.jar or gsql_client-3.0.0.jar . The default location where the .jar file is saved locally is ~/.gsql (which on Windows is \\Users\\<username>\\.gsql ). This can be changed using the initGsql() function's jarLocation parameter. The initGsql() needs to be called before any function that depends on the GSQL functionality (e.g. gsql() and getSchema() ) is invoked. Generally, the version of the database and the GSQL client must match. pyTigerGraph can query the version number of the database, and requests the appropriate client from the download location. In rare cases (when the changes/fixes do not impact the GSQL functionality) no new GSQL client version is released when a new version of the database is shipped. In these cases an appropriate GSQL client version needs to be manually specified via the gsqlVersion parameter (typically the latest available version that is lesser than the database version). You can check the list of available GSQL clients at the download location . NOTE: The intention is to replace the current functionality that uses the GSQL client with one that natively (i.e. using Python code only) communicates with the database. This is a short term plan, so look for changes in this are when you upgrade pyTgigerGraph (altough backward compatibility will be maintained). First, you will need to create a TigerGraphConnection . You can then initialize and test your connection by issuing any GSQL command like: print(conn.gsql('ls', options=[])) See the GSQL101 notebook for more examples. gsql conn.gsql(query, options=None) Runs a GSQL query and processes the output. Arguments: - query : The text of the query to run as one string. - options : A list of strings that will be passed as options the the GSQL client. A None gets replaced with ['g', self.graphname] causing the queries to run on the default graph. Use options=[] to overide the default graph and submit to the global graph instead. When the query resonse is a JSON formatted string the return value of gsql() would be a processed JSON object, otherwise the response text is returned as is. initGsql - OBSOLETE conn.initGsql(jarLocation=\"\", certLocation=\"\") OBSOLETE - GSQL initilization is handled automatically via gsql function. This function allows you to initiate the GSQL submodule ahead of the first call to any other GSQL submodule command. With it you to customize the location at which the GSQL client .jar and the SSL certificate will be stored. If the defaults (as shown above) are appropriate, you do not need to use this function.","title":"GSQL Functions"},{"location":"Gsql/#gsql-submodule","text":"pyTigerGraph uses the GSQL command line client to enable sending arbitrary GSQL statements to the database. This enables you to execute operations that are currently not available through REST API endpoints. The client is implemented in Java and distributed as a .jar archive. The client is downloaded on demand to the machine running your pyTigerGraph application; so you need to ensure that your code can access the download location and can save the .jar file locally. Furthermore, Java 8+ JRE must be installed and accessible on the machine. The .jar file is downloaded only if it's not yet available locally, i.e. it is downloaded only once for each database version accessed. Thus, you will potentially have multiple versions of the .jar file downloaded. The name pattern of the .jar file is gsql_client-x.y.z.jar , e.g. gsql_client-2.6.2.jar or gsql_client-3.0.0.jar . The default location where the .jar file is saved locally is ~/.gsql (which on Windows is \\Users\\<username>\\.gsql ). This can be changed using the initGsql() function's jarLocation parameter. The initGsql() needs to be called before any function that depends on the GSQL functionality (e.g. gsql() and getSchema() ) is invoked. Generally, the version of the database and the GSQL client must match. pyTigerGraph can query the version number of the database, and requests the appropriate client from the download location. In rare cases (when the changes/fixes do not impact the GSQL functionality) no new GSQL client version is released when a new version of the database is shipped. In these cases an appropriate GSQL client version needs to be manually specified via the gsqlVersion parameter (typically the latest available version that is lesser than the database version). You can check the list of available GSQL clients at the download location . NOTE: The intention is to replace the current functionality that uses the GSQL client with one that natively (i.e. using Python code only) communicates with the database. This is a short term plan, so look for changes in this are when you upgrade pyTgigerGraph (altough backward compatibility will be maintained). First, you will need to create a TigerGraphConnection . You can then initialize and test your connection by issuing any GSQL command like: print(conn.gsql('ls', options=[])) See the GSQL101 notebook for more examples.","title":"GSQL Submodule"},{"location":"Gsql/#gsql","text":"conn.gsql(query, options=None) Runs a GSQL query and processes the output. Arguments: - query : The text of the query to run as one string. - options : A list of strings that will be passed as options the the GSQL client. A None gets replaced with ['g', self.graphname] causing the queries to run on the default graph. Use options=[] to overide the default graph and submit to the global graph instead. When the query resonse is a JSON formatted string the return value of gsql() would be a processed JSON object, otherwise the response text is returned as is.","title":"gsql"},{"location":"Gsql/#initgsql-obsolete","text":"conn.initGsql(jarLocation=\"\", certLocation=\"\") OBSOLETE - GSQL initilization is handled automatically via gsql function. This function allows you to initiate the GSQL submodule ahead of the first call to any other GSQL submodule command. With it you to customize the location at which the GSQL client .jar and the SSL certificate will be stored. If the defaults (as shown above) are appropriate, you do not need to use this function.","title":"initGsql - OBSOLETE"},{"location":"OtherFunctions/","text":"Other Functions echo echo() Pings the database. Expected return value is \"Hello GSQL\" Documentation: GET /echo and POST /echo getEndpoints getEndpoints(builtin=False, dynamic=False, static=False) Lists the REST++ endpoints and their parameters. Arguments: - builtin : TigerGraph provided REST++ endpoints. - dymamic : Endpoints for user installed queries. - static : Static endpoints. If none of the above arguments are specified, all endpoints are listed. Documentation: GET /endpoints getStatistics getStatistics(seconds=10, segment=10) Arguments: - seconds : The duration of statistic collection period (the last n seconds before the function call). - segments : The number of segments of the latency distribution (shown in results as LatencyPercentile). By default, segments is 10, meaning the percentile range 0-100% will be divided into ten equal segments: 0%-10%, 11%-20%, etc. Segments must be [1, 100]. Retrieves real-time query performance statistics over the given time period. Documentation: GET /statistics getVersion getVersion() Retrieves the git versions of all components of the system. Documentation: GET /version getVer getVer(component=\"product\", full=False) Arguments: - component : One of TigerGraph's components (e.g. product, gpe, gse). Gets the version information of specific component. Get the full list of components using getVersion . getLicenseInfo - DEPRECATED getLicenseInfo() DEPRECATED - Functionality removed from TigerGraph product for any versions >v2.x Manage License on a \u2265v3.0 install through gadmin license Returns the expiration date and remaining days of the license. In case of evaluation/trial deployment, an information message and -1 remaining days are returned. createSecret conn.createSecret(alias=\"\") Returns a secret key. Takes in a string as an argument if you want to use an alias while generating the key.","title":"Other Functions"},{"location":"OtherFunctions/#other-functions","text":"","title":"Other Functions"},{"location":"OtherFunctions/#echo","text":"echo() Pings the database. Expected return value is \"Hello GSQL\" Documentation: GET /echo and POST /echo","title":"echo"},{"location":"OtherFunctions/#getendpoints","text":"getEndpoints(builtin=False, dynamic=False, static=False) Lists the REST++ endpoints and their parameters. Arguments: - builtin : TigerGraph provided REST++ endpoints. - dymamic : Endpoints for user installed queries. - static : Static endpoints. If none of the above arguments are specified, all endpoints are listed. Documentation: GET /endpoints","title":"getEndpoints"},{"location":"OtherFunctions/#getstatistics","text":"getStatistics(seconds=10, segment=10) Arguments: - seconds : The duration of statistic collection period (the last n seconds before the function call). - segments : The number of segments of the latency distribution (shown in results as LatencyPercentile). By default, segments is 10, meaning the percentile range 0-100% will be divided into ten equal segments: 0%-10%, 11%-20%, etc. Segments must be [1, 100]. Retrieves real-time query performance statistics over the given time period. Documentation: GET /statistics","title":"getStatistics"},{"location":"OtherFunctions/#getversion","text":"getVersion() Retrieves the git versions of all components of the system. Documentation: GET /version","title":"getVersion"},{"location":"OtherFunctions/#getver","text":"getVer(component=\"product\", full=False) Arguments: - component : One of TigerGraph's components (e.g. product, gpe, gse). Gets the version information of specific component. Get the full list of components using getVersion .","title":"getVer"},{"location":"OtherFunctions/#getlicenseinfo-deprecated","text":"getLicenseInfo() DEPRECATED - Functionality removed from TigerGraph product for any versions >v2.x Manage License on a \u2265v3.0 install through gadmin license Returns the expiration date and remaining days of the license. In case of evaluation/trial deployment, an information message and -1 remaining days are returned.","title":"getLicenseInfo - DEPRECATED"},{"location":"OtherFunctions/#createsecret","text":"conn.createSecret(alias=\"\") Returns a secret key. Takes in a string as an argument if you want to use an alias while generating the key.","title":"createSecret"},{"location":"PathFunctions/","text":"Path Finding Algorithms shortestPath shortestPath(sourceVertices, targetVertices, maxLength=None, vertexFilters=None, edgeFilters=None, allShortestPaths=False) Find the shortest path (or all shortest paths) between the source and target vertex sets. Arguments: - sourceVertices : A vertex set (a list of vertices) or a list of (vertexType, vertexID) tuples; the source vertices of the shortest paths sought. - targetVertices : A vertex set (a list of vertices) or a list of (vertexType, vertexID) tuples; the target vertices of the shortest paths sought. - maxLength : The maximum length of a shortest path. Optional, default is 6. - vertexFilters : An optional list of (vertexType, condition) tuples or {\"type\": <str>, \"condition\": <str>} dictionaries. - edgeFilters : An optional list of (edgeType, condition) tuples or {\"type\": <str>, \"condition\": <str>} dictionaries. - allShortestPaths : If true, the endpoint will return all shortest paths between the source and target. Default is false, meaning that the endpoint will return only one path. See more information on filters. Documentation: POST /shortestpath/{graphName} allPaths allPaths(sourceVertices, targetVertices, maxLength, vertexFilters=None, edgeFilters=None) Find all possible paths up to a given maximum path length between the source and target vertex sets. Arguments: - sourceVertices : A vertex set (a list of vertices) or a list of (vertexType, vertexID) tuples; the source vertices of the shortest paths sought. - targetVertices : A vertex set (a list of vertices) or a list of (vertexType, vertexID) tuples; the target vertices of the shortest paths sought. - maxLength : The maximum length of the paths. - vertexFilters : An optional list of (vertexType, condition) tuples or {\"type\": <str>, \"condition\": <str>} dictionaries. - edgeFilters : An optional list of (edgeType, condition) tuples or {\"type\": <str>, \"condition\": <str>} dictionaries. See more information on filters. Documentation: POST /allpaths/{graphName}","title":"Path Finding Algorithms"},{"location":"PathFunctions/#path-finding-algorithms","text":"","title":"Path Finding Algorithms"},{"location":"PathFunctions/#shortestpath","text":"shortestPath(sourceVertices, targetVertices, maxLength=None, vertexFilters=None, edgeFilters=None, allShortestPaths=False) Find the shortest path (or all shortest paths) between the source and target vertex sets. Arguments: - sourceVertices : A vertex set (a list of vertices) or a list of (vertexType, vertexID) tuples; the source vertices of the shortest paths sought. - targetVertices : A vertex set (a list of vertices) or a list of (vertexType, vertexID) tuples; the target vertices of the shortest paths sought. - maxLength : The maximum length of a shortest path. Optional, default is 6. - vertexFilters : An optional list of (vertexType, condition) tuples or {\"type\": <str>, \"condition\": <str>} dictionaries. - edgeFilters : An optional list of (edgeType, condition) tuples or {\"type\": <str>, \"condition\": <str>} dictionaries. - allShortestPaths : If true, the endpoint will return all shortest paths between the source and target. Default is false, meaning that the endpoint will return only one path. See more information on filters. Documentation: POST /shortestpath/{graphName}","title":"shortestPath"},{"location":"PathFunctions/#allpaths","text":"allPaths(sourceVertices, targetVertices, maxLength, vertexFilters=None, edgeFilters=None) Find all possible paths up to a given maximum path length between the source and target vertex sets. Arguments: - sourceVertices : A vertex set (a list of vertices) or a list of (vertexType, vertexID) tuples; the source vertices of the shortest paths sought. - targetVertices : A vertex set (a list of vertices) or a list of (vertexType, vertexID) tuples; the target vertices of the shortest paths sought. - maxLength : The maximum length of the paths. - vertexFilters : An optional list of (vertexType, condition) tuples or {\"type\": <str>, \"condition\": <str>} dictionaries. - edgeFilters : An optional list of (edgeType, condition) tuples or {\"type\": <str>, \"condition\": <str>} dictionaries. See more information on filters. Documentation: POST /allpaths/{graphName}","title":"allPaths"},{"location":"QueryFunctions/","text":"Query Functions getInstalledQueries getInstalledQueries(fmt=\"py\") Returns a list of installed queries. Arguments: - fmt : Format of the results: - \"py\": Python objects (default) - \"json\": JSON document - \"df\": Pandas DataFrame runInstalledQuery runInstalledQuery(queryName, params=None, timeout=None, sizeLimit=None) Runs an installed query. The query must be already created and installed in the graph. Use getEndpoints(dynamic=True) or GraphStudio to find out the generated endpoint URL of the query, but only the query name needs to be specified here. Arguments: - params : A string of param1=value1&param2=value2 format or a dictionary. - timeout : Maximum duration for successful query execution (in ms). Default: 16s. - sizeLimit : Maximum size of response (in bytes). Documentation: POST /query/{graph_name}/ Example: conn.runInstalledQuery(\"getUserInfo\", {\"userID\": \"user121\"}) runInterpretedQuery runInterpretedQuery(queryText, params=None, timeout=None, sizeLimit=None) Runs an interpreted query. You must provide the query text in this format: INTERPRET QUERY (<params>) FOR GRAPH <graph_name> { <statements> }' Arguments: - params : A string of param1=value1&param2=value2 format or a dictionary. - timeout : Maximum duration for successful query execution (in ms). Default: 16s. - sizeLimit : Maximum size of response (in bytes). Documentation: POST /gsqlserver/interpreted_query parseQueryOutput parseQueryOutput(output, graphOnly=True) Parses query output and separates vertex and edge data (and optionally other output) for easier use. The JSON output from a query can contain a mixture of results: vertex sets (the output of a SELECT statement), edge sets (e.g. collected in a global accumulator), printout of global and local variables and accumulators, including complex types (LIST, MAP, etc.). The type of the various output entries is not explicit, you need to inspect the content to find out what it is actually. This function \"cleans\" this output, separating and collecting vertices and edges in an easy to access way. It can also collect other output or ignore it. The output of this function can be used e.g. with the vertexSetToDataFrame() and edgeSetToDataFrame() functions or (after some transformation) to pass a subgraph to a visualisation component. Arguments: - output : The data structure returned by runInstalledQuery() or runInterpretedQuery() - graphOnly : Should output be restricted to vertices and edges (True, default) or should any other output (e.g. values of variables or accumulators, or plain text printed) be captured as well. Returns: A dictionary with two (or three) keys: \"vertices\", \"edges\" and optionally \"output\". First two refer to another dictionary containing keys for each vertex and edge types found, and the instances of those vertex and edge types. \"output\" is a list of dictionaries containing the key/value pairs of any other output.","title":"Query Functions"},{"location":"QueryFunctions/#query-functions","text":"","title":"Query Functions"},{"location":"QueryFunctions/#getinstalledqueries","text":"getInstalledQueries(fmt=\"py\") Returns a list of installed queries. Arguments: - fmt : Format of the results: - \"py\": Python objects (default) - \"json\": JSON document - \"df\": Pandas DataFrame","title":"getInstalledQueries"},{"location":"QueryFunctions/#runinstalledquery","text":"runInstalledQuery(queryName, params=None, timeout=None, sizeLimit=None) Runs an installed query. The query must be already created and installed in the graph. Use getEndpoints(dynamic=True) or GraphStudio to find out the generated endpoint URL of the query, but only the query name needs to be specified here. Arguments: - params : A string of param1=value1&param2=value2 format or a dictionary. - timeout : Maximum duration for successful query execution (in ms). Default: 16s. - sizeLimit : Maximum size of response (in bytes). Documentation: POST /query/{graph_name}/ Example: conn.runInstalledQuery(\"getUserInfo\", {\"userID\": \"user121\"})","title":"runInstalledQuery"},{"location":"QueryFunctions/#runinterpretedquery","text":"runInterpretedQuery(queryText, params=None, timeout=None, sizeLimit=None) Runs an interpreted query. You must provide the query text in this format: INTERPRET QUERY (<params>) FOR GRAPH <graph_name> { <statements> }' Arguments: - params : A string of param1=value1&param2=value2 format or a dictionary. - timeout : Maximum duration for successful query execution (in ms). Default: 16s. - sizeLimit : Maximum size of response (in bytes). Documentation: POST /gsqlserver/interpreted_query","title":"runInterpretedQuery"},{"location":"QueryFunctions/#parsequeryoutput","text":"parseQueryOutput(output, graphOnly=True) Parses query output and separates vertex and edge data (and optionally other output) for easier use. The JSON output from a query can contain a mixture of results: vertex sets (the output of a SELECT statement), edge sets (e.g. collected in a global accumulator), printout of global and local variables and accumulators, including complex types (LIST, MAP, etc.). The type of the various output entries is not explicit, you need to inspect the content to find out what it is actually. This function \"cleans\" this output, separating and collecting vertices and edges in an easy to access way. It can also collect other output or ignore it. The output of this function can be used e.g. with the vertexSetToDataFrame() and edgeSetToDataFrame() functions or (after some transformation) to pass a subgraph to a visualisation component. Arguments: - output : The data structure returned by runInstalledQuery() or runInterpretedQuery() - graphOnly : Should output be restricted to vertices and edges (True, default) or should any other output (e.g. values of variables or accumulators, or plain text printed) be captured as well. Returns: A dictionary with two (or three) keys: \"vertices\", \"edges\" and optionally \"output\". First two refer to another dictionary containing keys for each vertex and edge types found, and the instances of those vertex and edge types. \"output\" is a list of dictionaries containing the key/value pairs of any other output.","title":"parseQueryOutput"},{"location":"SchemaFunctions/","text":"getSchema getSchema(full=True) Retrieves the schema metadata of the graph. Arguments: - full : If False , returns metadata of vertices and edges only. If True , it will additionaly return additional info on vertices and egdes, plus info on UDTs, indices, loading jobs, queries, data sources, users and their roles, and proxy groups. The database user's privileges control how much data is returned for each object types. This functions uses the GSQL Submodule is full is True . Documentation: GET /gsqlserver/gsql/schema getUDTs getUDTs() Returns the list of User Defined Types (names only). getUDT getUDT(udtName) Returns the details of a specific User Defined Type. upsertData upsertData(data) Upserts data (vertices and edges) from a JSON document or equivalent object structure. TigerGraph Documentation: POST /graph","title":"Schema Functions"},{"location":"SchemaFunctions/#getschema","text":"getSchema(full=True) Retrieves the schema metadata of the graph. Arguments: - full : If False , returns metadata of vertices and edges only. If True , it will additionaly return additional info on vertices and egdes, plus info on UDTs, indices, loading jobs, queries, data sources, users and their roles, and proxy groups. The database user's privileges control how much data is returned for each object types. This functions uses the GSQL Submodule is full is True . Documentation: GET /gsqlserver/gsql/schema","title":"getSchema"},{"location":"SchemaFunctions/#getudts","text":"getUDTs() Returns the list of User Defined Types (names only).","title":"getUDTs"},{"location":"SchemaFunctions/#getudt","text":"getUDT(udtName) Returns the details of a specific User Defined Type.","title":"getUDT"},{"location":"SchemaFunctions/#upsertdata","text":"upsertData(data) Upserts data (vertices and edges) from a JSON document or equivalent object structure. TigerGraph Documentation: POST /graph","title":"upsertData"},{"location":"TokenManagement/","text":"Token Management If REST++ authentication is enabled , you must provide an authentication token with all request that access the REST++ endpoints. A token can be requested via the getToken function, which requires a secret. A secret can be created using the CREATE SECRET statement in GSQL or by the createSecret() function of pyTigerGraph. Notes : - If REST++ authentication is not enabled, then you do not need to provide a token (if you do, it will be ignored) and the functions below will raise exception. - You might not have the privilege to create secrets and thus you might need to request one first from the administrator of the TigerGraph instance. - Some pyTigerGraph functions communicate with the database through GraphStudio endpoints that use username/password based authentication, so you need to provide these independently from the token when you establish the connection to the database. For more info see Authentication . getToken getToken(secret, setToken=True, lifetime=None) Requests an authorisation token. This function returns a token only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - setToken : Set the connection's API token to the new value (default: True ). - lifetime : Duration of token validity (in secs, default 30 days = 2,592,000 secs). Returns a tuple of (<new_token>, <exporation_timestamp_unixtime>, <expiration_timestamp_ISO8601>) . Return value can be ignored. Note: expiration timestamp's time zone might be different from your computer's local time zone. Documentation: GET /requesttoken refreshToken refreshToken(secret, token=None, lifetime=2592000) Extends a token's lifetime. This function works only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - token : The token requested earlier. If not specified, refreshes current connection's token. - lifetime : Duration of token validity (in secs, default 30 days = 2,592,000 secs). Returns a tuple of (<token>, <exporation_timestamp_unixtime>, <expiration_timestamp_ISO8601>) . Return value can be ignored. Raises exception if specified token does not exists. Note: - New expiration timestamp will be now + lifetime seconds , not current expiration timestamp + lifetime seconds . - Expiration timestamp's time zone might be different from your computer's local time zone. Documentation: PUT /requesttoken deleteToken deleteToken(secret, token) Deletes a token. This function works only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - token : The token requested earlier. If not specified, deletes current connection's token, so be careful. - skipNA : Don't raise exception if specified token does not exist. Returns True if deletion was successful or token did not exist but skipNA was True ; raises exception otherwise. Documentation: DELETE /requesttoken","title":"API Tokens"},{"location":"TokenManagement/#token-management","text":"If REST++ authentication is enabled , you must provide an authentication token with all request that access the REST++ endpoints. A token can be requested via the getToken function, which requires a secret. A secret can be created using the CREATE SECRET statement in GSQL or by the createSecret() function of pyTigerGraph. Notes : - If REST++ authentication is not enabled, then you do not need to provide a token (if you do, it will be ignored) and the functions below will raise exception. - You might not have the privilege to create secrets and thus you might need to request one first from the administrator of the TigerGraph instance. - Some pyTigerGraph functions communicate with the database through GraphStudio endpoints that use username/password based authentication, so you need to provide these independently from the token when you establish the connection to the database. For more info see Authentication .","title":"Token Management"},{"location":"TokenManagement/#gettoken","text":"getToken(secret, setToken=True, lifetime=None) Requests an authorisation token. This function returns a token only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - setToken : Set the connection's API token to the new value (default: True ). - lifetime : Duration of token validity (in secs, default 30 days = 2,592,000 secs). Returns a tuple of (<new_token>, <exporation_timestamp_unixtime>, <expiration_timestamp_ISO8601>) . Return value can be ignored. Note: expiration timestamp's time zone might be different from your computer's local time zone. Documentation: GET /requesttoken","title":"getToken"},{"location":"TokenManagement/#refreshtoken","text":"refreshToken(secret, token=None, lifetime=2592000) Extends a token's lifetime. This function works only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - token : The token requested earlier. If not specified, refreshes current connection's token. - lifetime : Duration of token validity (in secs, default 30 days = 2,592,000 secs). Returns a tuple of (<token>, <exporation_timestamp_unixtime>, <expiration_timestamp_ISO8601>) . Return value can be ignored. Raises exception if specified token does not exists. Note: - New expiration timestamp will be now + lifetime seconds , not current expiration timestamp + lifetime seconds . - Expiration timestamp's time zone might be different from your computer's local time zone. Documentation: PUT /requesttoken","title":"refreshToken"},{"location":"TokenManagement/#deletetoken","text":"deleteToken(secret, token) Deletes a token. This function works only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - token : The token requested earlier. If not specified, deletes current connection's token, so be careful. - skipNA : Don't raise exception if specified token does not exist. Returns True if deletion was successful or token did not exist but skipNA was True ; raises exception otherwise. Documentation: DELETE /requesttoken","title":"deleteToken"},{"location":"VertexFunctions/","text":"getVertexTypes getVertexTypes() Returns the list of vertex type names of the graph. getVertexType getVertexType(vertexType) Returns the details of the specified vertex type. getVertexCount getVertexCount(vertexType, where=\"\") Return the number of vertices. Arguments: - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Uses: - If vertexType = \"*\": vertex count of all vertex types ( where cannot be specified in this case) - If vertexType is specified only: vertex count of the given type - If vertexType and where are specified: vertex count of the given type after filtered by where condition(s) See documentation for valid values of where condition. Returns a dictionary of <vertex_type>: <vertex_count> pairs. Documentation: GET /graph/{graph_name}/vertices and POST /builtins upsertVertex upsertVertex(vertexType, vertexId, attributes=None) Upserts a vertex. Data is upserted: - If vertex is not yet present in graph, it will be created. - If it's already in the graph, its attributes are updated with the values specified in the request. An optional operator controls how the attributes are updated. The attributes argument is expected to be a dictionary in this format: {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026} Example: {\"name\": \"Thorin\", \"points\": (10, \"+\"), \"bestScore\": (67, \"max\")} Returns a single number of accepted (successfully upserted) vertices (0 or 1). Documentation: POST /graph upsertVertices upsertVertices(vertexType, vertices) Upserts multiple vertices (of the same type). See the description of upsertVertex for generic information. The vertices argument is expected to be a list of tuples in this format: [ (<vertex_id>, {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026}), \u22ee ] Example: [ (2, {\"name\": \"Balin\", \"points\": (10, \"+\"), \"bestScore\": (67, \"max\")}), (3, {\"name\": \"Dwalin\", \"points\": (7, \"+\"), \"bestScore\": (35, \"max\")}), ] Returns a single number of accepted (successfully upserted) vertices (0 or positive integer). Documentation: POST /graph getVertices getVertices(vertexType, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves vertices of the given vertex type. Arguments: - select : Comma separated list of vertex attributes to be retrieved or omitted. - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of vertex instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. NOTE: The primary ID of a vertex instance is NOT an attribute, thus cannot be used in above arguments. Use getVerticesById if you need to retrieve by vertex ID. Documentation: GET /graph/{graph_name}/vertices getVerticesById getVerticesById(vertexType, vertexIds) Retrieves vertices of the given vertex type, identified by their ID. Arguments - vertexIds : A single vertex ID or a list of vertex IDs. Documentation: GET /graph/{graph_name}/vertices getVertexStats getVertexStats(vertexTypes, skipNA=False) Returns vertex attribute statistics. Arguments: - vertexTypes : A single vertex type name or a list of vertex types names or '*' for all vertex types. - skipNA : Skip those n on- a pplicable vertices that do not have attributes or none of their attributes have statistics gathered. Documentation: POST /builtins delVertices delVertices(vertexType, where=\"\", limit=\"\", sort=\"\", permanent=False, timeout=0) Deletes vertices from graph. Arguments: - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of vertex instances to be returned (after sorting). Must be used with sort . - sort : Comma separated list of attributes the results should be sorted by. Must be user with limit . - permanent : If true, the deleted vertex IDs can never be inserted back, unless the graph is dropped or the graph store is cleared. - timeout : Time allowed for successful execution (0 = no limit, default). NOTE: The primary ID of a vertex instance is NOT an attribute, thus cannot be used in above arguments. Use delVerticesById if you need to delete by vertex ID. Returns a single number of vertices deleted. Documentation: DELETE /graph/{graph_name}/vertices delVerticesById delVerticesById(vertexType, vertexIds, permanent=False, timeout=0) Deletes vertices from graph identified by their ID. Arguments: - vertexIds : A single vertex ID or a list of vertex IDs. - permanent : If true, the deleted vertex IDs can never be inserted back, unless the graph is dropped or the graph store is cleared. - timeout : Time allowed for successful execution (0 = no limit, default). Returns a single number of vertices deleted. Documentation: DELETE /graph/{graph_name}/vertices","title":"Vertex Functions"},{"location":"VertexFunctions/#getvertextypes","text":"getVertexTypes() Returns the list of vertex type names of the graph.","title":"getVertexTypes"},{"location":"VertexFunctions/#getvertextype","text":"getVertexType(vertexType) Returns the details of the specified vertex type.","title":"getVertexType"},{"location":"VertexFunctions/#getvertexcount","text":"getVertexCount(vertexType, where=\"\") Return the number of vertices. Arguments: - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Uses: - If vertexType = \"*\": vertex count of all vertex types ( where cannot be specified in this case) - If vertexType is specified only: vertex count of the given type - If vertexType and where are specified: vertex count of the given type after filtered by where condition(s) See documentation for valid values of where condition. Returns a dictionary of <vertex_type>: <vertex_count> pairs. Documentation: GET /graph/{graph_name}/vertices and POST /builtins","title":"getVertexCount"},{"location":"VertexFunctions/#upsertvertex","text":"upsertVertex(vertexType, vertexId, attributes=None) Upserts a vertex. Data is upserted: - If vertex is not yet present in graph, it will be created. - If it's already in the graph, its attributes are updated with the values specified in the request. An optional operator controls how the attributes are updated. The attributes argument is expected to be a dictionary in this format: {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026} Example: {\"name\": \"Thorin\", \"points\": (10, \"+\"), \"bestScore\": (67, \"max\")} Returns a single number of accepted (successfully upserted) vertices (0 or 1). Documentation: POST /graph","title":"upsertVertex"},{"location":"VertexFunctions/#upsertvertices","text":"upsertVertices(vertexType, vertices) Upserts multiple vertices (of the same type). See the description of upsertVertex for generic information. The vertices argument is expected to be a list of tuples in this format: [ (<vertex_id>, {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026}), \u22ee ] Example: [ (2, {\"name\": \"Balin\", \"points\": (10, \"+\"), \"bestScore\": (67, \"max\")}), (3, {\"name\": \"Dwalin\", \"points\": (7, \"+\"), \"bestScore\": (35, \"max\")}), ] Returns a single number of accepted (successfully upserted) vertices (0 or positive integer). Documentation: POST /graph","title":"upsertVertices"},{"location":"VertexFunctions/#getvertices","text":"getVertices(vertexType, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves vertices of the given vertex type. Arguments: - select : Comma separated list of vertex attributes to be retrieved or omitted. - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of vertex instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. NOTE: The primary ID of a vertex instance is NOT an attribute, thus cannot be used in above arguments. Use getVerticesById if you need to retrieve by vertex ID. Documentation: GET /graph/{graph_name}/vertices","title":"getVertices"},{"location":"VertexFunctions/#getverticesbyid","text":"getVerticesById(vertexType, vertexIds) Retrieves vertices of the given vertex type, identified by their ID. Arguments - vertexIds : A single vertex ID or a list of vertex IDs. Documentation: GET /graph/{graph_name}/vertices","title":"getVerticesById"},{"location":"VertexFunctions/#getvertexstats","text":"getVertexStats(vertexTypes, skipNA=False) Returns vertex attribute statistics. Arguments: - vertexTypes : A single vertex type name or a list of vertex types names or '*' for all vertex types. - skipNA : Skip those n on- a pplicable vertices that do not have attributes or none of their attributes have statistics gathered. Documentation: POST /builtins","title":"getVertexStats"},{"location":"VertexFunctions/#delvertices","text":"delVertices(vertexType, where=\"\", limit=\"\", sort=\"\", permanent=False, timeout=0) Deletes vertices from graph. Arguments: - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of vertex instances to be returned (after sorting). Must be used with sort . - sort : Comma separated list of attributes the results should be sorted by. Must be user with limit . - permanent : If true, the deleted vertex IDs can never be inserted back, unless the graph is dropped or the graph store is cleared. - timeout : Time allowed for successful execution (0 = no limit, default). NOTE: The primary ID of a vertex instance is NOT an attribute, thus cannot be used in above arguments. Use delVerticesById if you need to delete by vertex ID. Returns a single number of vertices deleted. Documentation: DELETE /graph/{graph_name}/vertices","title":"delVertices"},{"location":"VertexFunctions/#delverticesbyid","text":"delVerticesById(vertexType, vertexIds, permanent=False, timeout=0) Deletes vertices from graph identified by their ID. Arguments: - vertexIds : A single vertex ID or a list of vertex IDs. - permanent : If true, the deleted vertex IDs can never be inserted back, unless the graph is dropped or the graph store is cleared. - timeout : Time allowed for successful execution (0 = no limit, default). Returns a single number of vertices deleted. Documentation: DELETE /graph/{graph_name}/vertices","title":"delVerticesById"},{"location":"license/","text":"MIT License Copyright (c) 2020 Parker Erickson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}